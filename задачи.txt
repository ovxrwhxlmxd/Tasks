1. Определите класс футболиста, который содержит имя футболиста и его номер на поле. И определите класс футбольной команды,  который хранит 11 футболистов в виде массива и обеспечивает доступ к этим футболистам через индексатор.

2. Реализация кольцевого односвязанного списка

3. Реализовать кольцевой список, применив к нему интерфейс IEnumerable.

4. Создать интерфейс IAlgorithm, добавить в него пару методов. Например, сортировка и бинарный поиск. Применить интерфейс к кольцевому списку.

5. 
	Разработать приложение, имитирующее работу банкомата.
	Изначально имется несколько коллекций с заранее заполненными данными, имитирущими таблицы в базе данных
	(можно использовать БД, dataSet'ы и т.д.)

	Коллекция Пользователи - хранит информаци о польователях, зарегистрированных в банке
	List<User> = ..
	Id, Имя, фамилия, отчество, телефон, данные паспорта, дата регистрации, логин, пароль
	Коллекция Счета - хранит информацию о счетах польователей, у каждого пользователя может быть несколько счетов.
	List<Account>=...
	Id, дата открытия счёта, сумма на счёте, Id владельца
	Каждый счёт связан с пользователем по Id
	Коллекция История операций - хранит истори о всех операциях с конкретным счётом, имется 2 типа операции, пополнение и вывод денег со счёта.
	List<History> = ...
	Id, дата операции, тип операции, сумма, Id счёта
	Каждая запись в истории счвязана с конкретным счётом

	LINQ запросы:
	1. Вывод информации о заданном аккаунте по логину и паролю
	2. Вывод данных о всех счетах заданного пользователя
	3. Вывод данных о всех счетах заданного пользователя, включая историю по каждому счёту
	4. Вывод данных о всех операциях пополенения счёта с указанием владельца каждого счёта
	5. Вывод данных о всех пользователях у которых на счёте сумма больше N (N задаётся из вне и может быть любой)

6.
	Список URL-адресов
	Цель: Парсинг URL-адресов с заданной HTML-страницы.
	Составить регулярное выражение для поиска URL адресов в тексте (создавайте сами!)
	Написать программу, которая:
	1. На вход принимает URL-адрес,
	2. Загружает HTML-текст с этого адреса.
	3. Находит URL-адреса, используя регулярное выражение.
	4. Выводит на экран список всех найденных URL-адресов.

	В отчёте написать:
	1. Составленное регулярное выражение.
	2. Ссылку на репозиторий с вашим проектом.
	3. Сколько времени ушло на выполнение задания.
	
7. Реализовать класс Person, со свойствами Фамилия, Имя, Отчество и приватное поле зарплата и метод который вывод (Я такой-то зарабатываю столько то)
    Написать метод который отдает всю информацию о методанных класса, как есть поля в классе и какие модификаторы, 
	как есть функции, и вызов функции через рефлексию.
	
	Попробовать установить значение приватному полю через рефлексию
	
8. Реализовать класс с тремя функциями Sum(2 аргумента), Sum(3 аргумента), Sum(4 аргумента)
   Реализовать инициализацию этого класса и функций через рефлексию
   
9. Реализовать класс, который имеет закрытый список пользователей, реализовать в нем открытый метод, который принимает делегат
   как рандомный фильтр.
   
10. Реализовать класс, который имеет закрытый список пользователей, реализовать в нем открытый метод, который принимает название поля и значение, реализовать фильтрацию

11. Реализовать аттрибуты валидации телефонного номера и Email, с помощью рег. выражений

12*. Реализовать кастомный сериализатор в виде API, и атрибуты для маппинга этих значений, для полей и их типов
     Запрос принимает string, FormData
	 
	 Допустим строка приходит в таком виде, "name.alex,arr.[1],arr2.[[1],[2]]
	 
	 и я описываю класс
	 class Dto
	 {
	    [TestAttribute[name="name", type=Types.String]
		string FIO {get;set;}
		
		[TestAttribute[name="arr", type=Types.OrdianlArray, basetype=Types.Integer]
		string[] Massive {get;set;}
		
		[TestAttribute[name="arr2", type=Types.TwoDiimensionArray, basetype=Types.Integer]
		string[,] Massive {get;set;}
	 }
	 
	 в итоге дожно сериализовать в нужный Dto new CustomSerializtor().Serialize<Dto>(string request);
	 
13.
	Клиент - консольное приложение которое может подклчаться к серверу и отправлять ему сообщения.
	 При первом подключении клиент должен себя идентифицировать, отправить серверу своё имя (можно дополнительно любую другу информацию)
	Общение через TCP протокол (можно и через UDP на своё усмотрение). Использовать готовые фрэймворки и другие классы для взаимодейиствия
	между клиентом и сервером - МОЖНО.
	Сервер - консольное прилоежние, которое позволяет подключиться нескольким клиентам, регистрирует их (хранит массив текущих подклчённых 
	клиентов и данные о них "напрмиер имена") и поволяет им обмениваться сообщениями (когда какой-то клиент присылает сообщение - 
	сервер должен переслать его всем активным клиентам). 
	Когда сервер присылает клиенту сообщение - клиент должен его вывести в консоль. (формат на усмотрение программиста)

	Если возникнут проблемы с реализацией сетевого чата - можно реалиовать общение через файл. Условный сервер записывает данные в файл,
	 условный клиент при запуске или по команде считывает данне из файла и выводит. 

	Пересылка всех данных и для варианта с файлом и для варианта с сетевым взаимодествием должны передаваться в виде сериализованных
	объектов. 

	Обязательна обработка исклчений и оповещение клиента о возникших ошибках (не отправлять само исключение,
	 а только условное сообщение о ошибке, например: 
	ErrorMessage {
		message : "Ошибка десериализации"
		code: 503
	}
	)
	
14. Реализовать CRUD сервис который работает одновременной сразу с несколькими бд
    (mongo, clickhouse, postgres) и redis (который хранит сколько раз обращались к сервису и сколько был обработан запрос)
	реализовать метод отчет, который отдает информацию из redis, о том какая фунация в какое время была вызвана, и за сколько была отработана
	реализовать метод отчет, который отдает информацию из redis, о том сколько раз всего была вызвана та или иная фунация, и среднее время ее работы
    В базе должно быть не меньше 5 таблиц.
	
15.
	Написать класс, обходящий каталог файлов и выдающий событие при нахождении каждого файла
	Оформить событие и его аргументы с использованием .NET соглашений:
		 public event EventHandler<FileArgs> FileFound; 
		 FileArgs – будет содержать имя файла и наследоваться от EventArgs
	Добавить возможность отмены дальнейшего поиска из обработчика
	
16.
	Основное задание:
		Написать сериализацию свойств или полей класса в строку
		Проверить на классе: class F { int i1, i2, i3, i4, i5; Get() => new F(){ i1 = 1, i2 = 2, i3 = 3, i4 = 4, i5 = 5 }; }
		Замерить время до и после вызова функции
		(Для большей точности можно сериализацию сделать в цикле 100-100000 раз)
		Вывести в консоль полученную строку и разницу времен
		Отправить в чат полученное время с указанием среды разработки и количества итераций

		Для тех, кто быстр:
		Замерить время еще раз и вывести в консоль сколько потребовалось времени на вывод текста в консоль
		Провести сериализацию с помощью каких-нибудь стандартных механизмов (например в JSON)
		И тоже посчитать время и прислать результат сравнения

		Для самых быстрых или вторая часть домашнего задания:
		Написать десериализацию/загрузку данных из строки (ini/csv-файла) в экземпляр любого класса
		Замерить время на десериализацию
		Общий результат представить в таком виде:
			сериализуемый класс: class F { int i1, i2, i3, i4, i5;}
			код сериализации-десериализации: ...
			количество замеров: 1000 итераций
			мой рефлекшен: время на сериализацию = 100 мс, время на десериализацию = 100 мс
			стандартный механизм (NewtonsoftJson): время на сериализацию = 100 мс, время на десериализацию = 100 мс

17.
	a. Создать атрибут LastChangeAttribute, хранящий данные о последнем изменении класса, включающем имя изменившего, время изменения и номер задачи в рамках которой происходило изменение.
		[LastChange("Alex", DateTime.Parse("2019-12-02"), 11576)] 
		public class MyClass {} 
	
	b. Создать атрибут ExtendedInfoAttribute, который будет содержать тип метода: Getter (если только получает 
		данные ничего не изменяя), Setter (если только изменяет данные, но ничего не возвращает) и Boilerplate (если 
		делает и то, и другое). Помимо типа метода атрибут должен содержать описание того, что делает метод. 
		
		[ExtendedInfo("Getter", "Получает имя пользователя")] 
		public string GetUsername(int userId) 
		
	c. Создать атрибут TaxAttribute, который будет применяться к полям класса и содержать в себе данные о том, в каком 
		виде применяется налог: Fixed (фиксированная сумма) или Percentage (процент), а также периодичность налога: Monthly (помесячно) или Yearly (раз в год).
		
		[Tax(TaxType.Fixed, TaxFrequency.Monthly)] 
		public int value;
		
18.
	Узел == вершина графа
	Пункт 1.
	Создать Generic класс Граф (https://ru.wikipedia.org/wiki/%D0%93%D1%80%D0%B0%D1%84_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)).
	Класс Граф может работать только с объектами, реализущими интерфейс INode (интерфейс узла графа).

	Пример реализации INode:
	class Node<T> : INode<T>
	{
		int Id;
		T data = default(T);
	}

	Реализовать базовые функционал:
	1. Add - добавление узлов/узла графа (принимает аргумент/ы типа T или Id)
	2. Contains - проверяет, есть ли узел в графе содержащий объект типа T
	3. Remove - удаление узла графа типа T (принимает аргумент/ы типа T или Id)
	4. Получение значения (data) узла графа по Id
	5 - 6: добавить собственные 2 методы

	Пункт 2.
	Создать Generic класс RoadMap, унаследованный от класса Граф.
	Класс RoadMap содержит список городов и расстояния между ними (взвешенный граф) (http://brestprog.by/topics/dijkstra/).
	Добавить метод поиска кратчайшего пути между двумя городами, реализовав алгоритм Дейкстры или A* (можно использовать любой другой).
	Выводиться должен полный минимальный путь (все города, через которые необходимо будет проехать из города A в город B и расстояния между 
	этими города + общее расстояние).
	Каждый город должен быть представлен в виде отдельного класса.

	Инициалиация класса RoadMap может происходить из матрицы смежности (https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82%D1%80%D0%B8%D1%86%D0%B0_%D1%81%D0%BC%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8)
	или любыми другими способами (напрмиер, считывание и файла особой сруктуры). 

	Граф должен храниться в виде связанных между собой вершин, а не матрицы смежности.
	Примеры: https://prog-cpp.ru/data-graph/

	P.S.
	Если пункт 2 окажется слишком сложным - допускается реализация другого функционала.
	Реализовать метод сериализации графа в любой удобный формат (реализовать собственный сериализатор). 
	
19.
	Объявить указатель на два инта со значением 50:	Один – переменная класса	Другой – на стэке И выведем их положение в памяти в консоль

20.
	Реализуем шаблон "Прототип"
	Цель: Создаст иерархию из нескольких классов, в которых реализованы методы клонирования объектов по шаблону проектирования "Прототип".
	0. Придумать и создать 3-4 класса, которые как минимум дважды наследуются и написать краткое описание текстом.
	1. Создать свой интерфейс IMyCloneable для реализации шаблона "Прототип".
	2. Сделать возможность клонирования объекта для каждого из этих классов, используя вызовы родительских конструкторов.
	3. Составить тесты или написать программу для демонстрации функции клонирования.
	4. Добавить к каждому классу реализацию стандартного интерфейса ICloneable и реализовать его функционал через уже созданные методы.
	5. Написать вывод: какие преимущества и недостатки у каждого из интерфейсов: IMyCloneable и ICloneable.
	
21.
	Реализуем шаблон "Фасад"
	Цель: Написать программу, которая создаст мотиватор с использованием шаблона проектирования "Фасад".
	Мотиватор - это картинка с фоном, рамкой, фотографией и надписью, например:
	https://www.pressa.tv/uploads/posts/2013-09/1379566087_y20-kopiya.jpg

	Создайте систему классов и методов для формирования мотиватора:
	создание фоновой картинки константного размера, рисование рамки,
	загрузка картинки, изменение её размера, размещение надписи, сохранение мотиватора в файл.
	При необходимости используйте другие шаблоны.

	Создайте фасадный класс с одним методом, который использует
	систему ваших классов для компоновки мотиватора и возвращает имя созданного файла:

	string CreateMotivator(string image, string message)
	Подготовьте несколько картинок и код для тестирования программы.
	В описании напишите, какие шаблоны проектирования вы использовали.
	
22.
	Домашнее задание
	Реализуем шаблоны "Стратегия" и "Посетитель".
	Цель: Задача Сериализации геометрических фигур в разных форматах. Стратегией является процесс сериализации данных. Постетителем являются геометрические фигуры. Матрицу методов посетитетелей реализовать через двойную диспетчеризацию.
	1. Реализовать две стратегии с XML и JSON сериализацией, не используя сторонних библиотек.
	2. Реализовать трёх посетителей: точка, круг, квадрат.
	3. Каждый visit-метод должен вернуть сериализацию указанной фигуры в указанном формате.
	4. Составить тесты или написать программу для демонстрации функции клонирования.
	5. Приложить UML схему созданного проекта и ссылку на репозиторий.
	6. Написать вывод: какие преимущества и недостатки этих шаблонов проектирования применительно к данной задаче.
	
23.
	https://gitlab.com/devgrav/Otus.Teaching.Concurrency.Import
	https://gitlab.com/devgrav/Otus.Teaching.Concurrency.Queue
	Параллельный обработчик данных из файла
	Цель: Сделать параллельный обработчик файла с данными клиентов на основе подготовленного проекта с архитектурой. Задание поможет отработать основные инструменты параллелизма на реалистичной задаче.
	Программа-обработчик должна в параллельном режиме обработать файл с данными клиентов.

	Каждая строка файла содержит:

	id (целое число)
	ФИО (строка),
	Email (строка)
	Телефон (строка).

	Данные отсортированы по id. Нужно десериализовать данные клиента в объект и передать объект в метод класса, который сохраняет его в БД, вместо сохранения в БД можно сделать просто задержку.

	Задания

	1. Запуск генератора файла через создание процесса, сделать возможность выбора в коде, как запускать генератор, процессом или через вызов метода. Если вдруг встретится баг с генерацией, то его нужно исправить и написать об этом при сдаче работы.
	2. Распараллеливаем обработку файла по набору диапазонов Id, то есть нужно, чтобы файл разбивался на диапазоны по Id и обрабатывался параллельно через Thread, сколько диапазонов столько потоков. Хорошо сделать настройку с количеством потоков, чтобы можно было настроить оптимальное количество потоков под размер файла с данными. Предусмотреть обработку ошибок в обработчике и перезапуск по ошибке с указанием числа попыток. Проверить обработку на файле, в котором 1 млн. записей, при сдаче задания написать время, за которое был обработан файл и количество потоков.
	3. Вместо создания потоков через new Thread() использовать ThreadPool, при сдаче задания написать время, за которое был обработан файл и количество потоков.
	4. Добавить сохранение в реальную БД, можно SQL Lite для простоты тестирования или для лучшего понимания специфики загрузки полноценную базу данных (MS SQL Server, PostgreSQL, Mongo и т.д.)
	5. Сделать обработку файла в CSV формате, то есть написать генератор и разбор файла.

	Инструкция

	1. Сделать форк репозитория из ссылки в материалах, можно изменить структуру проектов, классов и интерфейсов, как считаете нужным и в ReadMe.md описать за что отвечает проект, класс, интерфейс.
	2. Реализовать 1 пункт задания, сделав в main проекта запуск процесса-генератора файла, его нужно будет собрать отдельно и передать в программу путь к .exe файлу, также сделать в Main вызов кода генератора из подключенного проекта, выбор между процессом или вызовом метода сделать настройкой (например аргумент командной строки или файл с настройками) со значением по умолчанию для метода.
	3. Реализовать 2 пункт задания, сделав свои реализации для IDataLoader и IDataParser.
	4. По желанию реализовать 3 пункт задания, сделав дополнительную реализацию IDataLoader.
	5. По желанию реализовать 4 пункт задания, сделав дополнительную реализацию для ICustomerRepository и инициализацию БД при старте приложения, можно использовать EF.
	6. По желанию реализовать 5 пункт задания, сделав дополнительную реализацию для IDataParser и IDataGenerator.
	
24.
	Имеется пустой участок земли (двумерный массив) и план сада, который необходимо реализовать. Эту задачу выполняют два садовника, которые не хотят встречаться друг с другом. Первый садовник начинает работу с верхнего левого угла сада и перемещается слева направо, сделав ряд, он спускается вниз. Второй садовник начинает работу с нижнего правого угла сада и перемещается снизу вверх, сделав ряд, он перемещается влево. Если садовник видит, что участок сада уже выполнен другим садовником, он идет дальше. Садовники должны работать параллельно. Создать многопоточное приложение, моделирующее работу садовников.
	
25.
	Напишите вычисление суммы элементов массива интов:
		Обычное
		Параллельное
		Параллельное с помощью LINQ

		Замерьте время выполнения и пришлите в чат в формате:
		Размер массива
		Код последовательного вычисления и время его выполнения
		Код параллельного вычисления и время его выполнения
		Код LINQ и время его выполнения

		Например:
		Размер массива = 1_000_000

		var sum = arr.Sum(x=>x);
		100 мс.

		var sum = 0;
		Parallel.For(0, Array.Length, i => sum+= arr[i]);
		200 мс.

26.
	Делаем проект асинхронным
	Цель: В этой домашней работе мы добавим асинхронные версии методов репозитория и генератора. Примечание: если для работы с базой данных уже есть асинхронные методы в адаптере к ней, то для генератора нужно будет создать асинхронный метод из синхронного самим.
	1. Доделать предыдущую работу по проекту https://gitlab.com/devgrav/Otus.Teaching.Concurrency.Import, если она ещё не закончена;
	2. Добавить асинхронные версии для всех методов репозитория и генератора и вызывать их вместо синхронных аналогов;
	3. Написать комментарий через Issue к двум работам других студентов.
  
27. Реализовать API с простейшей JWT авторизацией

28.
	Добавляем взаимодействие между клиентом и сервером
	Цель: В этой домашней работе мы применим на практике полученные знания по работе с REST API. Для уже хорошо знакомого нам проекта Otus.Teaching.Concurrency.Import необходимо будет добавить два внутренних проекта - WebApi и консольный клиент. Аналогично работе на самом уроке, консольный клиент должен отправлять в WebApi запрос на сохранение случайным образом сгенерированного пользователя. Сервер, в свою очередь, при добавлении пользователя должен проверять наличие пользователя в БД и возвращать коды ответов: - 200, если пользователь добавлен без ошибок; - 409, если пользователь с таким Id уже существует в базе. Также, должен быть метод получения пользователя по идентификатору, а сервер должен отдавать статус-код 200 с информацией о пользователе, если он есть, либо 404, если пользователь не был найден.
	1. Доделать предыдущую работу по проекту https://gitlab.com/devgrav/Otus.Teaching.Concurrency.Import, если она ещё не закончена;
	2. Создать проект WebApi с методом GET /users/{id}; - 4 балла
	3. Создать проект консольного приложения принимающего с консоли ID, запрашивающего и отображающего данные по пользователю;
	4. Добавить поддержку метода POST /users/ - 2 балла;
	5. Добавить генерацию случайного пользователя в консольном приложении и его отправку на сервер для сохранения - 2 балла;
	
29.
	Добавить кэширование к прошлому ДЗ. (28 задача)
	На 8 баллов.
	Реализуем простеший механизм кэширования (прокси), занося все запросы в кэш
	На 10 баллов.
	Реализуем механизм кэширования с учётом популярности запроса и необходимости его дольше держать в кэше в случае, если запрос популярен.
	В обоих случаях информация в кэше всегда должна обновляться и быть актуальной.
	
30. 
	Создаём два микросервиса с общением через брокер сообщений
	Цель: В результате выполнения ДЗ вы получите практические навыки работы с брокером сообщений RabbitMQ. Официальная документация: https://www.rabbitmq.com/tutorials/tutorial-one-dotnet.html
	1. Создайте аккаунт на cloudamqp.com и экземпляр кластера RabbitMQ;
	2. Создайте приложение, которое создаст очередь с названием "homework" и раз в секунду будет отправлять в неё сериализованный объект класса User {string name, int age, string email};
	3. Создайте приложение, читающее сообщения из очереди "homework" и показывающее их на экране;
	4. Сделайте так, чтобы читающее приложение делало Ack только тем сообщениям, в которых у пользователей заполнен email.
	
31. Реализовать приложение API (имитация работы кофе-аппарата с приемом купюр)
    использовать бд (mongo)
	Основные сущности купюроприемник(1 рубль, 5, 10, 50, 100, 1000)
	Выбор кофе
	Сдача
	Отмена исполнения (работа с транзакциями)
	
	Реализация, IRepository (с оновными CRUD операциями), IUnitOfWork
	Реализация луковой архитектуры 
	в центре domain, repository
	далее сервисы
	запросы
	
32. Реализовать через дженерики, основные структуры данных - связанный список, двусвязанные список, очередь, стек, графы (обход графа по ширине и глубине), Хэш таблицы
	 
	 
33. Пройти часть - https://ulearn.me/Course/BasicProgramming2/Praktika_Eksponentsial_noe_sglazhivanie__c334ede2-2c35-4fcb-94cb-fb1c48e3e7bb

34. https://ulearn.me/course/BasicProgramming2/Listy_i_indeksatsiya_ff0b5f9b-eb8c-432d-8bab-4bfa9718469a

35. https://ulearn.me/course/BasicProgramming2/Postanovka_problemy_139a55f6-8e6a-4178-bccc-a152a5eecea5

36. https://ulearn.me/course/BasicProgramming2/O_funktsional_nom_programmirovanii_32ae8e0b-a96e-48ef-8ba0-43c0bc04f403

37. https://ulearn.me/course/BasicProgramming2/Vvedenie_3446fab2-15df-4045-ab40-abc1f3dc87c8

38. https://ulearn.me/course/BasicProgramming2/Opredelenie_grafa_1525edc4-1193-48ea-8f9a-061647cd469e

39. https://ulearn.me/course/BasicProgramming2/Kombinatornye_zadachi_8661d8aa-fdc5-4185-8ba3-5651b18acd48

40. https://ulearn.me/course/BasicProgramming2/Tredy_domeny_i_protsessy_4dd557b3-7903-4ff4-932a-a95b4a7fb15f

41. https://ulearn.me/course/BasicProgramming2/DP_na_zadache_planirovaniya_vremeni_12a270df-5fc8-46d1-a3b8-ab34c07e8167

42. https://ulearn.me/course/BasicProgramming2/Ochered_s_prioritetami_0dd9a1e8-c370-493d-b384-94c62f04bf34

43. https://ulearn.me/course/BasicProgramming2/Refleksiya_Klass_Type_8386b127-ea69-465d-87ba-24e08df9f6d2

44. https://ulearn.me/course/basicprogramming2/48016626-87ae-411d-ae97-f7a49e465dbc