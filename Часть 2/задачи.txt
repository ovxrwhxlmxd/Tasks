https://gitlab.com/devgrav/otus.teaching.promocodefactory/-/wikis/Home

1. Реализовать API, подключить Swagger, AutoMapper и простейшой с JWT Авторизацией, Serilog авторизацию

2. Реализация простейшего DI с временем жизни

3.
	Добавить Entity Framework Core в DataAccess проект и сделать реализацию IRepository в виде EfRepository, которая будет работать с DataContext Entity Framework.
	Добавить SQLite в качестве БД
	База должна удаляться и создаваться каждый раз, заполняясь тестовыми данными из FakeDataFactory.
	Настроить маппинг классов Employee, Roles, Customer,Preference и PromoCode на базу данных через EF. Обратить внимание, что PromoCode имеет ссылку на Preference и Employee имеет ссылку на Role. Customer имеет набор Preference, но так как Preference - это общий справочник и сущности связаны через Many-to-many, то нужно сделать маппинг через сущность CustomerPreference. Строковые поля должны иметь ограничения на MaxLength.
	Связь Customer и Promocode реализовать через One-To-Many, будем считать, что в данном примере промокод может быть выдан только одному клиенту из базы.
	Реализовать CRUD операции для CustomersController через репозиторий EF, нужно добавить новый Generic класс EfRepository. Получение списка, получение одного клиента, создание/редактирование и удаление, при удалении также нужно удалить ранее выданные промокоды клиента. Методы должны иметь xml комментарии для описания в Swagger. CustomerResponse также должен возвращать список предпочтений клиента с той же моделью PrefernceResponse
	Нужно реализовать контроллер, который возвращает список предпочтений (Preference) в виде PrefernceResponse модели из базы данных. Метод должен иметь xml комментарии для описания в Swagger.
	В качестве дополнительного задания реализовать методы PromoCodesController. Метод GivePromocodesToCustomersWithPreferenceAsync должен сохранять новый промокод в базе данных и находить клиентов с переданным предпочтением и добавлять им данный промокод. GetPromocodesAsync - здесь даты передаются строками, чтобы не было проблем с часовыми поясами
	В качестве дополнительного задания реализовать две миграции: начальную миграцию и миграцию с изменением любого поля на выбор, в этом случае удаление на каждый запуск уже не должно происходить
	
4.
	Добавляем docker-compose файл, где конфигурируем PostgreSQL БД.
	Добавляем начальную миграцию БД	
	Настраиваем сборку на Gitlab
	
5.
	Написать тесты к своему проекту и добавить их прогон в CI
	Цель: Задание поможет отработать навыки написания тестов в ASP.NET Core проектах на xUnit.

	Новые требования:
	1. Для нормальной работы с партнерами решили добавить в систему список партнеров и вести их активность, также будет сохраняться количество промокодов, которые выдал партнер;
	2. Приняли решение для части партнеров в ручном порядке продавать подписку на использование API. Для контроля подписки вводим лимиты на выдачу промокодов для партнеров и при попытке выдать промокод будем контролировать лимиты;
	3. Лимиты будем задавать и отменять через API. Лимиты должны иметь дату создания, окончания и если отменим до даты окончания, то дату отмены, а также количество промокодов в лимите.
	В домашнем задании нужно протестировать установку лимитов партнеру.

	Тесты можно писать в файле SetPartnerPromoCodeLimitAsyncTests в проекте UnitTests.

	Сделать форк репозитория Homework 4 (https://gitlab.com/devgrav/otus.teaching.promocodefactory.homework.unittests) домашнего задания и реализовать пункты в нем.

	Нужно протестировать следующие Test Cases для установки партнеру (класс Partner) лимита (класс PartnerLimit) метод SetPartnerPromoCodeLimitAsync в PartnersController):

	1. Если партнер не найден, то также нужно выдать ошибку 404;
	2. Если партнер заблокирован, то есть поле IsActive=false в классе Partner, то также нужно выдать ошибку 400;
	3. Если партнеру выставляется лимит, то мы должны обнулить количество промокодов, которые партнер выдал NumberIssuedPromoCodes, если лимит закончился, то количество не обнуляется;
	4. При установке лимита нужно отключить предыдущий лимит;
	5. Лимит должен быть больше 0;
	6. Нужно убедиться, что сохранили новый лимит в базу данных (это нужно проверить Unit-тестом);

	Если в текущей реализации найдутся ошибки, то их нужно исправить и желательно написать тест, чтобы они больше не повторялись.

	Тесты должны соответствовать следующим условиям:
	1. Использовать именование: ИмяЕдиницыТестирования_Условие_ОжидаемыйРезультат;
	2. Для Arrange этапа должен использоваться фабричный метод при определении данных;
	3. Для Stub и Mock использовать Moq;
	4. Для создания тестируемого класса, например, PartnersController можно использовать AutoFixture (https://habr.com/ru/post/262435/), чтобы избежать ошибок компиляции при добавлении новых зависимостей в конструктор или также использовать фабричный метод;
	5. Для проверки утверждения в тестах должен использоваться FluentAssertions;
	6. В качестве дополнительного условия тестовые данные должны формироваться с помощью Builder, если не будет использоваться AutoFixture, то Mock и Stub также должны настраиваться через Builder;
	7. В качестве дополнительного условия можно провести рефакторинг PartnersController или только метода SetPartnerPromoCodeLimitAsync на свое усмотрение, может быть ввести дополнительные классы для повышения удобства тестирования и сопровождения, если появятся дополнительные классы и методы, то они тоже должны быть протестированы, принцип расположения тестов в проекте соответствующий тестам в примере (Например, WebHost/Controllers/PartnersControllerTests); Если будет сделан рефакторинг, то при сдаче ДЗ поясните какие классы были введены;
	8. В качестве дополнительного условия можно добавить прогон тестов CI в GitLab и при сдаче ДЗ прислать ссылку на прогон.
	Критерии оценки: Написаны все тесты и они проходят - 6 баллов;
	
6.
	Реализуем API аналогичный Customers с помощью 2-х разных подходов из технологий: gRPC, GraphQL или SignalR; Например, GRPC и GraphQL;
	
7.
	Цель:
	Подготовить документ-план распила монолита на микросервисы.

	Выбрать крупную, известную вам информационную систему, в примере по ссылке https://docs.google.com/spreadsheets/d/1Y-0ExAXsmt-tyQOgjAZv43ReCvMUR5kVcpGN1ppQWGw/edit?usp=sharing представлено Яндекс.Такси. Описать ее назначение и один или несколько ее бизнес процессов
	Определить необходимые микросервисы, и их назначение (должно быть не менее 5)
	Описать взаимодействие сервисов в рамках одного из бизнес-сценариев. Т.е. какой микросервис с кем взаимодействует, какие данные передает, какие ожидает и способ взаимодействия (синхронно (какая технология?) или асинхронно (какая технология?)) Например, при запросе от пользователя нам необходимо: проверить не исключен ли он, затем построить маршрут на основе маршрута у тарификатора получить данные о стоимости и т.д.
	Использовать паттер strangler для одного из микросервисов
	
8.
	https://gitlab.com/devgrav/otus.teaching.promocodefactory/-/wikis/Home
	
	Необходимо подключить NoSql базу данных к одному из микросервисов или распределенный кеш на Redis, на выбор.

	Mongo
	В качестве NoSQL базы можно использовать Mongo и перенести туда данные и работу с ними для одного из микросервисов на выбор: модуля Администрирование либо модуля Предложение промокодов клиентам.
	Mongo образ нужно будет добавить в docker-compose: image: "mongo:4.2.3"

	Модуль Администрирование

	В модуле Администрирование (Otus.Teaching.Pcf.Administration) нужно изменить хранение сущностей Employee и Role в MongoDb, реализовать новый репозиторий для работы с Mongo, плюс обеспечить работу текущих контроллеров с новым хранилищем.

	Модуль Предложение промокодов клиентам

	Если хочется лучше познакомиться с Mongo, то можно реализовать более сложный функционал из микросервиса Предложение промокодов клиентам (Otus.Teaching.Pcf.GivingToCustomer). Необходимо перенести хранение сущностей в Mongo вместо Postgress и реализовать функционал, приведенный в контроллерах на новом хранилище.

	Redis
	Если вместо Mongo хочется поработать с Redis, то в Redis кэш можно перенести справочник предпочтений Preference и во всех микросервисах обращаться к этим данным через Redis кэш и интерфейс IDistributedCache.
	Так как предпочтения сейчас нужны в двух микросервисах, то при получении промокода от партнера и при выдаче клиентам выглядит правильным реализовать микросервис со справочной информацией, где сохранять предпочтений в СУБД, а для быстрого доступа использовать распределенный кеш или локальный кеш микросервиса. Тогда сервис справочной информации нужно будет добавить в docker-compose и сделать его сборку в Dockerfile по аналогии с другими сервисами, плюс при получении данных предпочтений в Otus.Teaching.Pcf.GivingToCustomer и Otus.Teaching.Pcf.ReceivingFromPartner вызывать новый микросервис, который будет использовать кеш.
	Однако, для простоты реализации кеш можно добавить только в один из текущих микросервисов и вместо базы получать предпочтения из него.

	Инструкция по запуску
	Проект состоит из трех микросервисов и их баз данных, настройка Posgress баз для них приведена в docker-compose файле в корне репозитория, чтобы запустить только базы данных выполняем команду:
	docker-compose up promocode-factory-administration-db promocode-factory-receiving-from-partner-db promocode-factory-giving-to-customer-db
	Сами сервисы доступны в общем solution: Otus.Teaching.Pcf.sln
	Если базы данных запущены, то в Visual Studio или Rider настраиваем запуск нескольких проектов сразу и работаем с API через Swagger, для API в Swagger добавлены примеры данных для вызова и тестирования
	
9.
	Добавляем RabbitMq в docker-compose файл.
	Подключаем RabbitMq в микросервисы Выдача промокода клиенту (Otus.Teaching.Pcf.GivingToCustomer), Администрирование (Otus.Teaching.Pcf.Administration) и по желанию в Получение промокода от партнера (Otus.Teaching.Pcf.ReceivingFromPartner). Можно использовать драйвер RabbitMq для .NET, тогда вероятно нужно будет использовать Hosted Service для прослушивания очереди, также можно использовать MassTransit или NServiceBus.
	При получении промокода от партнера в микросервисе Otus.Teaching.Pcf.ReceivingFromPartner в методе ReceivePromoCodeFromPartnerWithPreferenceAsync контроллера PartnersController в конце выполнения сейчас происходят вызовы _givingPromoCodeToCustomerGateway и _administrationGateway, где через HTTPClient изменяются данных в других микросервисах, такой способ является синхронным и при росте нагрузке или отказе одного из сервисов приведет к отказу всей операции.
	Для повышения надежности вместо синхронных вызовов нужно отправлять одно событие в RabbitMq, тогда в микросервисах  Otus.Teaching.Pcf.Administration и по желанию в Otus.Teaching.Pcf.GivingToCustomer нужно сделать подписку на данное событие и реализовать аналог текущих синхронных операций, вызываемых через API.
	Для того, чтобы ту же логику можно было вызвать из консюмера очереди ее надо перенести из контроллера в класс-сервис, который нужно разместить в проекте Core, в контроллере и консюмере очереди надо вызывать метод этого сервиса.


	Инструкция по запуску
	Проект состоит из трех микросервисов и их баз данных, настройка Posgress баз для них приведена в docker-compose файле в корне репозитория, чтобы запустить только базы данных выполняем команду:
	docker-compose up promocode-factory-administration-db promocode-factory-receiving-from-partner-db promocode-factory-giving-to-customer-db
	Сами сервисы доступны в общем solution: Otus.Teaching.Pcf.sln
	Если базы данных запущены, то в Visual Studio или Rider настраиваем запуск нескольких проектов сразу и работаем с API через Swagger, для API в Swagger добавлены примеры данных для вызова и тестирования.
	
10.
	Добавить админку используя Razor page. Админка должнав позволять редактировать добавлять удалять и просматривать:

	Предпочтения
	Промокоды
	Пользователей
	Дополнительные таблицы по желанию